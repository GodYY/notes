# 前言

做大数据的同学经常会有这样的需求：
给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。

或者也可以这么说：
要求从N个元素中随机的抽取k个元素，其中N的大小未知。

很多同学说，擦，这还不简单么，将所有元素保存在一个列表中，然后再随机取k个不就完了么。
好吧，如果你不是专门搞大大大数据的同学，这么说我觉得情有可原。如果你真的是天天跟大大大数据打交道的同学，这么说的话就显得不那么professional了。大数据最重要的特点是什么？一个字，大大大啊！重要的问题必须说三遍。大，那意味着什么？意味着内存放不下呀！所以，我们才需要通过设计精巧的算法，来降低对内存的渴求，达到我们最终的目的。当然可能有土豪会反驳我，俺们公司就是牛逼，俺们就是有钱，内存无限加，128G不够上256G，256G还不够我直接给你加1T内存，反正就是一句话，内存管够！碰到这样的土豪，我也只能淡淡一笑：128G内存到1T内存，即使加上了，也只是翻了10倍。但是现在数据量的增长速度，一般来说可是远远要大于硬件设备的扩容速度的。所以最终，还是需要通过更加精致的算法来解决问题，硬件扩容不是解决问题的根本办法。

# 算法讲解

#### 蓄水池算法的具体思路是：

先初始化一个集合，集合中有k个元素，将此集合作为蓄水池。然后从第k+1个元素开始遍历，并且按一定的概率替换掉蓄水池里面的元素。

来自《The Art of Computer Programming》里的伪代码：

```
Init : a reservoir with the size： k  
for i= k+1 to N  
    M=random(1, i);  
    if( M < k)  
     SWAP the Mth value and ith value  
end for   
```

#### 具体描述如下：

先将前k个数取出放入蓄水池中，然后从第k+1个数开始遍历。假设遍历到第i个数，以$\frac{k}{i}$的概率替换掉蓄水池中某个元素即可。

#### 简单证明一下每个元素取出的概率是相同的：

