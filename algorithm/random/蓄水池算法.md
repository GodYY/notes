# 前言

做大数据的同学经常会有这样的需求：
给出一个数据流，这个数据流的长度很大或者未知。并且对该数据流中数据只能访问一次。请写出一个随机选择算法，使得数据流中所有数据被选中的概率相等。

或者也可以这么说：
要求从N个元素中随机的抽取k个元素，其中N的大小未知。

很多同学说，擦，这还不简单么，将所有元素保存在一个列表中，然后再随机取k个不就完了么。
好吧，如果你不是专门搞大大大数据的同学，这么说我觉得情有可原。如果你真的是天天跟大大大数据打交道的同学，这么说的话就显得不那么professional了。大数据最重要的特点是什么？一个字，大大大啊！重要的问题必须说三遍。大，那意味着什么？意味着内存放不下呀！所以，我们才需要通过设计精巧的算法，来降低对内存的渴求，达到我们最终的目的。当然可能有土豪会反驳我，俺们公司就是牛逼，俺们就是有钱，内存无限加，128G不够上256G，256G还不够我直接给你加1T内存，反正就是一句话，内存管够！碰到这样的土豪，我也只能淡淡一笑：128G内存到1T内存，即使加上了，也只是翻了10倍。但是现在数据量的增长速度，一般来说可是远远要大于硬件设备的扩容速度的。所以最终，还是需要通过更加精致的算法来解决问题，硬件扩容不是解决问题的根本办法。

# 算法讲解

#### 蓄水池算法的具体思路是：

先初始化一个集合，集合中有k个元素，将此集合作为蓄水池。然后从第k+1个元素开始遍历，并且按一定的概率替换掉蓄水池里面的元素。

来自《The Art of Computer Programming》里的伪代码：

```
Init : a reservoir with the size： k  
for i= k+1 to N  
    M=random(1, i);  
    if( M < k)  
     SWAP the Mth value and ith value  
end for   
```

#### 具体描述如下：

先将前k个数取出放入蓄水池中，然后从第k+1个数开始遍历。假设遍历到第i个数，以$\frac{k}{i}$的概率替换掉蓄水池中某个元素即可。

#### 简单证明一下每个元素取出的概率是相同的：

假设$n-1$时成立，即前$n$个数据被返回的概率都是$\frac{1}{n-1}$。当前正在读第$n$个数据，数据被返回的概率为$\frac{1}{n}$。那么前$n-1$个元素被返回的概率为$\frac{1}{n-1}*(1-\frac{1}{n})=\frac{1}{n}$，即当有$n$个数据的时候，前$n-1$个元素被选中的概率也是$\frac{1}{n}$，假设成立。

#### 用数学归纳法证明如下：

问题：

​	取前k个元素放入蓄水池中，从$i=k+1$开始，以$\frac{k}{i}$的概率取第$i$个元素。若被选中，已均等的概率替换掉蓄水池中先前被选中的元素。证明这样的选取方式，可以让每个元素被选中的概率相等。

证明：

​	当$i=k+1$时，元素$i$被选中的概率为$\frac{k}{k+1}$，而前$k$个元素被选中的概率为$1-被选中元素替换的概率=1-\frac{k}{k+1}*\frac{1}{k}=\frac{k}{k+1}$，说明前$k+1$个元素被选中的概率都是相等的“$\frac{k}{k+1}$”。

​	再假设$i=n$时，前面$n$个元素都已$\frac{k}{n}$的概率被选中。那么当$i=n+1$时，第$n+1$个元素被选中的概率为$\frac{k}{n+1}$。

​	对于前面的 n 个元素，每个元素被选中的情况分两种：

  1. 第$n+1$个元素没有被选中

  2. 第$n+1$个元素被选中，但是没有将其替换掉

     此时，前$n$个元素被选中的概率为：
     $$
     \frac{k}{n}*(1-\frac{k}{n+1})+\frac{k}{n}*\frac{k}{n+1}*(1-\frac{1}{k})=\frac{k}{n+1}
     $$
     由此可见，第$n+1$步也满足假设条件。所以，问题得到证明。

# 代码示例

```go
func reservoir(n []int, k int) []int {
  ret := make([]int, k)
  copy(ret, n)
  for i := k; i < len(n); i++ {
    if rand.Intn(i+1) < k {
      ret[rand.Intn(k)] = n[i]
    }
  }
  return n
} 
```

# 讲在最后

蓄水池算法是一种无序的抽取算法，即是说，无论$n$个元素之间在抽取之前是什么样的顺序，抽取后在结果中的顺序都是不确定的，因为在抽取过程中，池中先前被抽中的元素，都有可能被随机替换出去。
