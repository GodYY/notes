在编程中，尤其是编写游戏的过程中经常会遇到在m个东西中取出n个东西的需求，这个时候一般人都会想到随机n个数出来，然后在原来的列表中去凑这n个数的下标。这样会导致许多的问题，例如很难保证不出现重复的随机数，更重要的是我们会为了避免这些问题去做许多没有意义的循环从而严重的影响了效率。当 m 比较大，越来越接近 n 时，重复的概率也会大大增加，这样时间复杂度就会升高。下面进行定量分析。

假设之前已经生成了 x 个数，接下来生成第 x+1 个数。

- 第一次调用 random 就成功生成第 x+1 个随机数的概率为 $1 - \frac{x}{n}$
- 第二次调用random就成功生成第x+1个数的概率为$(1-\frac{x}{n})\frac{x}{n}$

- 第k次调用random就成功生成第x+1个数的概率为$(1-\frac{x}{n})(\frac{x}{n})^{k-1}$

那么生成第x+1个数需要调用random方法的次数为（期望值，即平均次数）：
$$
E(x+1)=(1-\frac{x}{n})*1+(1-\frac{x}{n})\frac{x}{n}*2+...+(1-\frac{x}{n})\frac{x}{n}^{k-1}*k+...=\frac{n}{n-x}
$$
上述等差-等比数列求和的方法，只需要中学数学知识即可理解。

根据上式，调用 random 方法的总期望次数为：
$$
E(random)=\frac{n}{n}+\frac{n}{n-1}+...+\frac{n}{n-m-1}\approx O(n(\lg(n)-\lg(n-m)))
$$
当 m 接近 n 时，上式所代表的时间复杂度接近$O(n\lg{n})$，算法复杂度较高。

下面是更高效的算法。

# 从 n 个样本中有序抽出 m 个样本 $O(n)$

假设总共有 n 个样本，而我们需要随机取出 m 个样本。那么其中每一个元素被取出的概率为：
$$
\frac{m}{n}
$$
则第一个元素被取出的概率为$\frac{m}{n}$。

而第二个元素被取出的概率有如下两种情况：

- 如果第一个元素被取出，那么下一个元素被取出的概率为：$\frac{m-1}{n-1}$
- 如果第一个元素未被取出，那么下一个元素被取出的概率为：$\frac{m}{n-1}$

可以看出，当一个元素被取出时，下一个元素被取出的概率会降低，而当一个元素未被取出时，下一个元素被取出的概率会提高。这时我们可以推导出一个元素被取出的概率为：
$$
\frac{要取的个数-已经取出的个数}{总数-已经遍历的个数}
$$
转化为公式：
$$
\frac{m-k}{n-i+1}
$$
其中 $k$ 为已抽中数，$i$ 为筛选元素序号。

可以很容易地得出从全局来看每一个元素取出概率都是相同的，且仅需要一次循环就可以满足需求，时间复杂度为$O(n)$。

代码示例：

```go
func mfromn(n []int, m int) []int {
  ret := make([]int, m)
  k := 0
  for i:=0; i < len(n) && k < m; i++ {
    if rand.Float64() < float64(m-k) / float64(n-i) {
    	ret[k] = n[i]
      k++
    }
  }
  return ret
}

// 优化版
func mfromn2(n []int, m int) []int {
  ret := make([]int, m)
  k := 0
  for i:=0; i < len(n) && k < m; i++ {
    // 不等式两边同时乘以 （n-i）
    if rand.Intn(n-i) < m-k{
    	ret[k] = n[i]
      k++
    }
  }
  return ret
}
```



