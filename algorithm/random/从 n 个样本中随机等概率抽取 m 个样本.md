在编程中，尤其是编写游戏的过程中经常会遇到在m个东西中取出n个东西的需求，这个时候一般人都会想到随机n个数出来，然后在原来的列表中去凑这n个数的下标。这样会导致许多的问题，例如很难保证不出现重复的随机数，更重要的是我们会为了避免这些问题去做许多没有意义的循环从而严重的影响了效率。当 m 比较大，越来越接近 n 时，重复的概率也会大大增加，这样时间复杂度就会升高。下面进行定量分析。

假设之前已经生成了 x 个数，接下来生成第 x+1 个数。

- 第一次调用 random 就成功生成第 x+1 个随机数的概率为 $1 - \frac{x}{n}$
- 第二次调用random就成功生成第x+1个数的概率为$(1-\frac{x}{n})\frac{x}{n}$

- 第k次调用random就成功生成第x+1个数的概率为$(1-\frac{x}{n})(\frac{x}{n})^{k-1}$

那么生成第x+1个数需要调用random方法的次数为（期望值，即平均次数）：
$$
E(x+1)=(1-\frac{x}{n})*1+(1-\frac{x}{n})\frac{x}{n}*2+...+(1-\frac{x}{n})\frac{x}{n}^{k-1}*k+...=\frac{n}{n-x}
$$
上述等差-等比数列求和的方法，只需要中学数学知识即可理解。

根据上式，调用 random 方法的总期望次数为：
$$
E(random)=\frac{n}{n}+\frac{n}{n-1}+...+\frac{n}{n-m-1}\approx O(n(\lg(n)-\lg(n-m)))
$$
当 m 接近 n 时，上式所代表的时间复杂度接近$O(n\lg{n})$，算法复杂度较高。

下面是更高效的算法。

# 随机抽样 空间复杂度$O(n)$ 时间复杂度$O(m)$

初始化一个额外$O(n)$空间的数组来存储样本。每次迭代从数组中随机选择，并将抽中的样本与数组末尾未抽中的样本进行交换，避免抽到重复样本。

或者，总共抽 m 次，每次抽的序号为 i（1~m），每次从 i~n 的序号中随机抽中一个样本，抽中后将样本与 i 位置的样本进行替换。

```go
func sample(n []int, m int) []int {
  ln := len(n)
  nn := make([]int, ln)
  copy(nn, n)
  ret := make([]int, m)
  for i := 0; i < m; i++ {
    k := rand.Intn(n-i)
    ret[i] = nn[k]
   	nn[k] = nn[n-i-1]
  }
  return ret
}
```

这里时间复杂度为$O(m)$，但是需要额外的$O(n)$空间来存储样本。

不适用于$n$很大的情况。

证明：

​	从描述中可以得知，n 中的每个样本，都有 m 次机会被抽中。假设 k 是 n 中任意一个样本：

​	k 第一次被抽中的概率为$P(1)=\frac{1}{n}$。

​	k 第二次被抽中的概率为P(2)=$(1-\frac{1}{n})*\frac{1}{n-1}=\frac{n-1}{n}*\frac{1}{n-1}=\frac{1}{n}$。

​	依次类推，第 m 次被抽中的概率为
$$
\begin{aligned}
P(m) 
& =(1-\frac{1}{n})*(1-\frac{1}{n-1})*(1-\frac{1}{n-2})*...*(1-\frac{1}{n-m+2})*\frac{1}{n-m+1} \\
& = \frac{n-1}{n}*\frac{n-2}{n-1}*\frac{n-3}{n-2}*...*\frac{n-m+1}{n-m+2}*\frac{1}{n-m+1} \\
& = \frac{1}{n}
\end{aligned}
$$
​	那么 k 被抽中的概率为$P(1)+P(2)+...+P(m)=\frac{m}{n}$。证毕！

# 选择抽样 结果有序 $O(n)$

假设总共有 n 个样本，而我们需要随机取出 m 个样本。那么其中每一个元素被取出的概率为：
$$
\frac{m}{n}
$$
则第一个元素被取出的概率为$\frac{m}{n}$。

而第二个元素被取出的概率有如下两种情况：

- 如果第一个元素被取出，那么下一个元素被取出的概率为：$\frac{m-1}{n-1}$
- 如果第一个元素未被取出，那么下一个元素被取出的概率为：$\frac{m}{n-1}$

可以看出，当一个元素被取出时，下一个元素被取出的概率会降低，而当一个元素未被取出时，下一个元素被取出的概率会提高。这时我们可以推导出一个元素被取出的概率为：
$$
\frac{要取的个数-已经取出的个数}{总数-已经遍历的个数}
$$
转化为公式：
$$
\frac{m-k}{n-i+1}
$$
其中 $k$ 为已抽中数，$i$ 为筛选元素序号。

可以很容易地得出从全局来看每一个元素取出概率都是相同的，且仅需要一次循环就可以满足需求，时间复杂度为$O(n)$。用数学归纳法证明如下：

​	首先，证明第二个元素被取出的概率为$\frac{m}{n}$。第二个元素被抽中有两种情况，一种是第一、第二个元素都被抽中（$\frac{m}{n}*\frac{m-1}{n-1}$）；另一种是第一个元素未抽中，第二个元素被抽中（$(1-\frac{m}{n})*\frac{m}{n-1}$。所以，在全局状况下，第二个元素被抽中的概率为$\frac{m}{n}*\frac{m-1}{n-1}+(1-\frac{m}{n})*\frac{m}{n-1}=\frac{m}{n}$，说明第二个元素被抽中的概率同样为$\frac{m}{n}$。

​	推广到取第i个元素时也同样成立，但证明过程较复杂，在此不列出。可参考 《Art of Computer Programing 第三卷 半数值算法》。
```go
func sample(n []int, m int) []int {
  ret := make([]int, m)
  k := 0
  for i:=0; i < len(n) && k < m; i++ {
    if rand.Float64() < float64(m-k) / float64(n-i) {
    	ret[k] = n[i]
      k++
    }
  }
  return ret
}

// 优化版
func sample2(n []int, m int) []int {
  ret := make([]int, m)
  k := 0
  for i:=0; i < len(n) && k < m; i++ {
    // 不等式两边同时乘以 （n-i）
    if rand.Intn(n-i) < m-k{
    	ret[k] = n[i]
      k++
    }
  }
  return ret
}
```

# 蓄水池抽样

假设 n 是已知的，即可采用蓄水池抽样。
